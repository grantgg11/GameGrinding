package utils;

import static org.junit.jupiter.api.Assertions.*;

import java.io.IOException;
import java.nio.file.*;
import java.util.Base64;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;

import org.junit.jupiter.api.*;
import org.junit.jupiter.api.parallel.ResourceLock;
import static org.junit.jupiter.api.parallel.Resources.SYSTEM_PROPERTIES;

/**
 * KeyStorageTest verifies the functionality of the KeyStorage utility class, focusing on encryption key creation, storage, loading,
 * and error handling.
 *
 * Tests cover:
 * - Generating a new AES key when none exists and persisting it in Base64 format.
 * - Returning the same key on subsequent getEncryptionKey calls without overwriting.
 * - Storing keys with automatic parent directory creation.
 * - Loading stored keys and verifying byte equality with the original.
 * - Throwing appropriate exceptions for missing or corrupt key files.
 *
 * File I/O is isolated using a temporary home directory with overridden system
 * properties, ensuring no interaction with real user data. SYSTEM_PROPERTIES
 * resource locking prevents race conditions in parallel tests.
 *
 * Lifecycle methods set up the test environment, clean up files after each test,
 * and restore original system properties afterward.
 */
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
@ResourceLock(SYSTEM_PROPERTIES) 
class KeyStorageTest {

    private Path tempHome;
    private Path keyDir;
    private Path keyPath;

    private String prevKeyDirProp;
    private String prevKeyPathProp;
    private String prevUserHome;

    /**
     * Sets up a temporary directory and configures KeyStorage
     * to use it before all tests run.
     *
     * @throws Exception if the temporary directory cannot be created
     */
    @BeforeAll
    void setUp() throws Exception {
        tempHome = Files.createTempDirectory("gg-home-");
        keyDir = tempHome.resolve(".gamegrinding");
        keyPath = keyDir.resolve("encryption.key");

        prevKeyDirProp  = System.getProperty("gamegrinding.keyDir");
        prevKeyPathProp = System.getProperty("gamegrinding.keyPath");
        prevUserHome    = System.getProperty("user.home");

        System.setProperty("gamegrinding.keyDir", keyDir.toString());
        System.setProperty("user.home", tempHome.toString());
    }

    /**
     * Cleans up any key files or directories created during a test.
     *
     * @throws Exception if files cannot be deleted
     */
    @AfterEach
    void cleanFiles() throws Exception {
        if (Files.exists(keyPath)) Files.deleteIfExists(keyPath);
        if (Files.exists(keyDir)) {
            try (var s = Files.list(keyDir)) {
                if (s.findAny().isEmpty()) Files.deleteIfExists(keyDir);
            }
        }
        if (Files.exists(tempHome)) {
            try (var s = Files.list(tempHome)) {
                if (s.findAny().isEmpty()) Files.deleteIfExists(tempHome);
            }
        }
    }

    /**
     * Restores the original system property values after all tests complete.
     *
     * @throws Exception if system properties cannot be restored
     */
    @AfterAll
    void tearDown() throws Exception {
        // Restore props
        restore("gamegrinding.keyDir", prevKeyDirProp);
        restore("gamegrinding.keyPath", prevKeyPathProp);
        restore("user.home", prevUserHome);
    }

    /**
     * Restores a single system property to its previous value.
     *
     * @param key   the property name
     * @param value the original value, or null to clear the property
     */
    private void restore(String key, String value) {
        if (value == null) System.clearProperty(key);
        else System.setProperty(key, value);
    }


    /**
     * Creates a byte array of the given length, incrementing values from a seed.
     *
     * @param len  number of bytes
     * @param seed starting byte value
     * @return the generated byte array
     */
    private static byte[] bytes(int len, byte seed) {
        byte[] b = new byte[len];
        for (int i = 0; i < len; i++) b[i] = (byte) (seed + i);
        return b;
    }

    /**
     * Verifies that getEncryptionKey() generates and stores a key when no key file exists.
     *
     * @throws Exception if key creation or file I/O fails
     */
    @Test
    void getEncryptionKey_generatesAndPersists_whenMissing() throws Exception {
        assertFalse(Files.exists(keyPath));
        SecretKey key = KeyStorage.getEncryptionKey();
        assertNotNull(key);
        assertTrue(Files.exists(keyPath));

        byte[] diskDecoded = Base64.getDecoder().decode(Files.readAllBytes(keyPath));
        assertArrayEquals(key.getEncoded(), diskDecoded);
    }

    /**
     * Verifies that getEncryptionKey() loads an existing key without overwriting it.
     *
     * @throws Exception if key storage or retrieval fails
     */
    @Test
    void getEncryptionKey_returnsExisting_withoutOverwriting() throws Exception {
        byte[] known = bytes(32, (byte) 7);
        SecretKey knownKey = new SecretKeySpec(known, "AES");
        KeyStorage.storeKey(knownKey);

        SecretKey loaded = KeyStorage.getEncryptionKey();
        assertArrayEquals(known, loaded.getEncoded());
    }

    /**
     * Verifies that storing and loading a key returns the same bytes.
     *
     * @throws Exception if key storage or retrieval fails
     */
    @Test
    void storeKey_then_loadKey_roundTrip() throws Exception {
        byte[] data = bytes(16, (byte) 42);
        SecretKey original = new SecretKeySpec(data, "AES");

        KeyStorage.storeKey(original);
        SecretKey roundTripped = KeyStorage.loadKey();
        assertArrayEquals(original.getEncoded(), roundTripped.getEncoded());
    }

    /**
     * Verifies that loading a key when the file does not exist throws an IOException.
     */
    @Test
    void loadKey_whenMissing_throwsIOException() {
        assertFalse(Files.exists(keyPath));
        assertThrows(IOException.class, KeyStorage::loadKey);
    }

    /**
     * Verifies that loading a key with invalid Base64 content throws an exception.
     *
     * @throws Exception if file writing fails
     */
    @Test
    void loadKey_whenCorruptBase64_throws() throws Exception {
        Files.createDirectories(keyDir);
        Files.writeString(keyPath, "not-base64!");
        assertThrows(IllegalArgumentException.class, KeyStorage::loadKey);
    }

    /**
     * Verifies that storeKey(SecretKey) creates parent directories if they do not already exist.
     *
     * @throws Exception if key storage fails
     */

    @Test
    void storeKey_createsParentDirsIfNeeded() throws Exception {
        if (Files.exists(keyDir)) {
            Files.walk(keyDir)
                 .sorted((a,b)->b.getNameCount()-a.getNameCount())
                 .forEach(p -> { try { Files.deleteIfExists(p); } catch (Exception ignored) {} });
        }

        byte[] data = bytes(16, (byte) 1);
        SecretKey k = new SecretKeySpec(data, "AES");
        KeyStorage.storeKey(k);

        assertTrue(Files.exists(keyPath));
        assertTrue(Files.exists(keyDir));
    }

    /**
     * Verifies that calling getEncryptionKey() multiple times returns a key with the same byte content each time.
     *
     * @throws Exception if key retrieval fails
     */
    @Test
    void getEncryptionKey_idempotent_returnsSameBytesOnSubsequentCalls() throws Exception {
        SecretKey k1 = KeyStorage.getEncryptionKey();
        SecretKey k2 = KeyStorage.getEncryptionKey();
        assertArrayEquals(k1.getEncoded(), k2.getEncoded());
    }
}
